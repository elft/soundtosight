class SerpentOfHarmonyVisualizer extends BaseVisualizer{constructor(t,s){super(t,{backgroundColor:"#0a0a12",force2d:!0,stereo:!0,...s})}init(){this.segments=80,this.wavePhase=0,this.movementSpeed=0,this.undulationAmplitude=0,this.serpentThickness=0,this.hue=180,this.targetHue=180,this.scalePhase=0,this.scaleGlow=0,this.serpentLean=0,this.shedSkinLayers=[],this.lastBassDrop=0,this.smoothedBass=0,this.smoothedMid=0,this.smoothedBrilliance=0,this.smoothedRms=0,this.trail=[],this.maxTrailLength=8}onUpdate(t){const s=.15;this.smoothedRms=this.lerp(this.smoothedRms,t.rms||0,s),this.smoothedBass=this.lerp(this.smoothedBass,t.bassEnergy||0,s),this.smoothedMid=this.lerp(this.smoothedMid,t.midEnergy||0,s),this.smoothedBrilliance=this.lerp(this.smoothedBrilliance,t.brillianceEnergy||0,s);const e=t.dominantFreq||200;this.targetHue=this.map(Math.log(e),Math.log(20),Math.log(2e4),200,360),this.hue=this.lerp(this.hue,this.targetHue,.05),this.serpentThickness=this.map(this.smoothedRms,0,.5,10,50),this.undulationAmplitude=this.map(this.smoothedBass,0,1,20,150),this.movementSpeed=this.map(this.smoothedMid,0,1,.01,.08),this.scaleGlow=this.smoothedBrilliance,this.scalePhase+=.1*this.smoothedBrilliance,this.serpentLean=this.lerp(this.serpentLean,.3*(t.stereoBalance||0),.1),t.isBeat&&(this.wavePhase+=.5),t.bassDrop&&t.time-this.lastBassDrop>.3&&(this.shedSkin(),this.lastBassDrop=t.time),this.wavePhase+=this.movementSpeed,this.updateSkinLayers()}onRender(){const t=this.ctx;t.fillStyle="rgba(10, 10, 18, 0.15)",t.fillRect(0,0,this.width,this.height);const s=this.calculateSerpentPath();this.drawSerpentGlow(s),this.drawSerpentBody(s),this.drawSerpentScales(s)}calculateSerpentPath(){const t=[],s=this.width/2,e=this.height/2;if(this.height>this.width)for(let e=0;e<this.segments;e++){const h=e/this.segments,i=Math.sin(h*Math.PI*5+this.wavePhase)*this.undulationAmplitude,a=Math.cos(h*Math.PI*4+.8*this.wavePhase)*this.undulationAmplitude*.5,n=Math.sin(h*Math.PI*7+1.2*this.wavePhase)*this.undulationAmplitude*.25,o=h*this.height,l=s+i+a+n+80*this.serpentLean,r=(e+1)/this.segments,d=Math.sin(r*Math.PI*5+this.wavePhase)*this.undulationAmplitude,u=Math.cos(r*Math.PI*4+.8*this.wavePhase)*this.undulationAmplitude*.5,c=Math.sin(r*Math.PI*7+1.2*this.wavePhase)*this.undulationAmplitude*.25,p=r*this.height,M=s+d+u+c+80*this.serpentLean,m=Math.atan2(p-o,M-l);t.push({x:l,y:o,t:h,angle:m})}else for(let h=0;h<this.segments;h++){const i=h/this.segments,a=Math.sin(i*Math.PI*4+this.wavePhase)*this.undulationAmplitude,n=Math.cos(i*Math.PI*3+.7*this.wavePhase)*this.undulationAmplitude*.6,o=Math.sin(i*Math.PI*6+1.3*this.wavePhase)*this.undulationAmplitude*.3,l=s+n+(i-.5)*this.width*.4+100*this.serpentLean,r=e+a+o+50*Math.sin(i*Math.PI),d=(h+1)/this.segments,u=Math.sin(d*Math.PI*4+this.wavePhase)*this.undulationAmplitude,c=Math.cos(d*Math.PI*3+.7*this.wavePhase)*this.undulationAmplitude*.6,p=Math.sin(d*Math.PI*6+1.3*this.wavePhase)*this.undulationAmplitude*.3,M=s+c+(d-.5)*this.width*.4+100*this.serpentLean,m=e+u+p+50*Math.sin(d*Math.PI),P=Math.atan2(m-r,M-l);t.push({x:l,y:r,t:i,angle:P})}return t}drawSerpentGlow(t){const s=this.ctx;s.shadowBlur=40,s.shadowColor=`hsla(${this.hue}, 100%, 60%, 0.6)`,s.beginPath(),s.moveTo(t[0].x,t[0].y);for(let e=1;e<t.length;e++)s.lineTo(t[e].x,t[e].y);s.strokeStyle=`hsla(${this.hue}, 80%, 50%, 0.3)`,s.lineWidth=2*this.serpentThickness,s.lineCap="round",s.lineJoin="round",s.stroke(),s.shadowBlur=0}drawSerpentBody(t){const s=this.ctx;for(let e=0;e<t.length-1;e++){const h=t[e],i=t[e+1],a=h.t,n=this.serpentThickness*(1-.5*Math.abs(a-.5)),o=30*Math.sin(a*Math.PI*2+this.wavePhase),l=40+20*a+30*this.smoothedRms,r=s.createLinearGradient(h.x,h.y,i.x,i.y);r.addColorStop(0,`hsl(${this.hue+o}, 70%, ${l}%)`),r.addColorStop(1,`hsl(${this.hue+o+10}, 70%, ${l+5}%)`),s.beginPath(),s.moveTo(h.x,h.y),s.lineTo(i.x,i.y),s.strokeStyle=r,s.lineWidth=n,s.lineCap="round",s.stroke()}const e=t[t.length-1],h=1.5*this.serpentThickness;s.shadowBlur=30,s.shadowColor=`hsla(${this.hue}, 100%, 70%, 0.8)`,s.beginPath(),s.arc(e.x,e.y,h,0,2*Math.PI),s.fillStyle=`hsl(${this.hue}, 80%, 60%)`,s.fill();const i=.4*h,a=.25*h,n=e.x+Math.cos(e.angle+Math.PI/4)*i,o=e.y+Math.sin(e.angle+Math.PI/4)*i,l=e.x+Math.cos(e.angle-Math.PI/4)*i,r=e.y+Math.sin(e.angle-Math.PI/4)*i;s.shadowBlur=15,s.shadowColor="#fff",s.fillStyle="#ffffff",s.beginPath(),s.arc(n,o,a,0,2*Math.PI),s.fill(),s.beginPath(),s.arc(l,r,a,0,2*Math.PI),s.fill(),s.shadowBlur=0}drawSerpentScales(t){const s=this.ctx;for(let e=0;e<t.length-1;e+=8){const h=t[e],i=h.t,a=(.5*Math.sin(i*Math.PI*8+this.scalePhase)+.5)*this.scaleGlow;if(a<.1)continue;const n=this.serpentThickness*(1-.5*Math.abs(i-.5)),o=.3*n*(1+.5*a),l=h.angle+Math.PI/2,r=.5*n,d=h.x+Math.cos(l)*r,u=h.y+Math.sin(l)*r,c=h.x-Math.cos(l)*r,p=h.y-Math.sin(l)*r;s.shadowBlur=10+20*a,s.shadowColor=`hsla(${this.hue+40}, 100%, 70%, ${a})`,s.fillStyle=`hsla(${this.hue+40}, 100%, 70%, ${.8*a})`,s.beginPath(),s.arc(d,u,o,0,2*Math.PI),s.fill(),s.beginPath(),s.arc(c,p,o,0,2*Math.PI),s.fill()}s.shadowBlur=0}shedSkin(){const t=`skin-${Date.now()}`,s=this.createOverlay(t,0),e=s.ctx;s.canvas.style.transformOrigin="center center";const h=this.calculateSerpentPath();this.drawSerpentSkinLayer(e,h),this.shedSkinLayers.push({id:t,overlay:s,yOffset:0,rotation:0,rotationDirection:.01*(Math.random()>.5?1:-1),alpha:.9,life:1})}drawSerpentSkinLayer(t,s){t.save(),t.shadowBlur=60,t.shadowColor=`hsla(${this.hue}, 100%, 60%, 1)`,t.beginPath(),t.moveTo(s[0].x,s[0].y);for(let e=1;e<s.length;e++)t.lineTo(s[e].x,s[e].y);t.strokeStyle=`hsla(${this.hue}, 90%, 60%, 0.5)`,t.lineWidth=2*this.serpentThickness,t.lineCap="round",t.lineJoin="round",t.stroke(),t.shadowBlur=40,t.shadowColor=`hsla(${this.hue}, 100%, 60%, 0.9)`;for(let e=0;e<s.length-1;e++){const h=s[e],i=s[e+1],a=h.t,n=this.serpentThickness*(1-.5*Math.abs(a-.5)),o=30*Math.sin(a*Math.PI*2+this.wavePhase),l=55+20*a;t.beginPath(),t.moveTo(h.x,h.y),t.lineTo(i.x,i.y),t.strokeStyle=`hsla(${this.hue+o}, 85%, ${l}%, 0.8)`,t.lineWidth=1.3*n,t.lineCap="round",t.stroke()}for(let e=0;e<s.length-1;e+=6){const h=s[e],i=h.t,a=this.serpentThickness*(1-.5*Math.abs(i-.5)),n=.4*a,o=h.angle+Math.PI/2,l=.6*a;t.shadowBlur=25,t.shadowColor=`hsla(${this.hue+40}, 100%, 70%, 0.9)`,t.fillStyle=`hsla(${this.hue+40}, 90%, 60%, 0.8)`,t.beginPath(),t.arc(h.x+Math.cos(o)*l,h.y+Math.sin(o)*l,n,0,2*Math.PI),t.fill(),t.beginPath(),t.arc(h.x-Math.cos(o)*l,h.y-Math.sin(o)*l,n,0,2*Math.PI),t.fill()}t.restore()}updateSkinLayers(){for(let t=this.shedSkinLayers.length-1;t>=0;t--){const s=this.shedSkinLayers[t];s.yOffset-=1.5,s.rotation+=s.rotationDirection,s.life-=.008,s.alpha=Math.max(0,s.life);const e=s.overlay.canvas;e.style.transform=`translateY(${s.yOffset}px) rotate(${s.rotation}rad)`,e.style.opacity=s.alpha,(s.life<=0||s.yOffset<1.5*-this.height)&&(this.removeOverlay(s.id),this.shedSkinLayers.splice(t,1))}}onResize(){this.trail=[];for(const t of this.shedSkinLayers)this.removeOverlay(t.id);this.shedSkinLayers=[]}}"undefined"!=typeof window&&(window.SerpentOfHarmonyVisualizer=SerpentOfHarmonyVisualizer);