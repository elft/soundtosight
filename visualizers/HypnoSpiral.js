class HypnoSpiralVisualizer extends BaseVisualizer{static meta={description:"Mathematical spirals and pulse waves that bloom smoothly with each beat.",tags:["chill","psychedelic","lofi","trance"]};constructor(t,s){super(t,{backgroundColor:"#000000",force2d:!0,stereo:!1,...s})}init(){this.rings=[],this.maxRings=6,this.baseRadius=.06*Math.min(this.width,this.height),this.globalRotation=0,this.growthBase=1,this.lastRms=0,this.minThickness=.8,this.maxThickness=20,this.minArms=2,this.maxArms=8,this.centroidHistory=[],this.centroidHistorySize=40,this.melodyStableCount=0,this.melodyStableThreshold=18,this.hueDrift=0,this.hueDriftSpeed=.15,this.currentShape="spiral",this.minSpawnInterval=150,this.lastSpawnTime=0,this.spawnTimestamps=[],this.maxSpawnsPerSecond=4,this.pulses=[],this._lastBass=0,this.bassColorWave={active:!1,startTime:0,duration:800,baseHue:0},this.centerX=this.width/2,this.centerY=this.height/2}onResize(){this.baseRadius=.06*Math.min(this.width,this.height),this.centerX=this.width/2,this.centerY=this.height/2}onUpdate(t){if(!t)return;const s=this.constrain(t.rms||0,0,1),i=this.constrain(t.centroid||1e3,0,22050),e=this.constrain(t.spectralFlux||0,0,10),a=this.constrain(t.bassEnergy||0,0,1),h=this.constrain(t.midEnergy||0,0,1),n=this.constrain(t.trebleEnergy||0,0,1);this.globalRotation+=.6*e;const r=this.map(s,0,1,.2,6)*this.growthBase;(t.isBeat||t.isBeatSpike)&&this._canSpawn()&&this._spawnRing({rms:s,centroid:i,flux:e,bass:a,mids:h,highs:n,growthSpeed:r,onset:!0})&&this._registerSpawn();const o=performance.now();o-this.lastSpawnTime>this.minSpawnInterval&&this._canSpawn()&&Math.random()<.01+.06*s&&this._spawnRing({rms:s,centroid:i,flux:e,bass:a,mids:h,highs:n,growthSpeed:r,onset:!1})&&this._registerSpawn(),this.centroidHistory.push(i),this.centroidHistory.length>this.centroidHistorySize&&this.centroidHistory.shift();const l=this.centroidHistory.reduce((t,s)=>t+s,0)/Math.max(1,this.centroidHistory.length);this.centroidHistory.reduce((t,s)=>t+Math.pow(s-l,2),0)/Math.max(1,this.centroidHistory.length)<1200?this.melodyStableCount++:this.melodyStableCount=0,this.melodyStableCount>=this.melodyStableThreshold?this.hueDrift+=this.hueDriftSpeed*(1+s):this.hueDrift*=.98;const c=a-this._lastBass;c>.28&&a>.35&&(this._spawnPulse({strength:c,hue:this._centroidToHue(i)}),this.bassColorWave.active=!0,this.bassColorWave.startTime=o,this.bassColorWave.baseHue=this._centroidToHue(i)+180),this._lastBass=a;for(let t=this.rings.length-1;t>=0;t--){const i=this.rings[t];i.radius+=r*(1+i.growthMultiplier),i.rotation+=.8*e*i.rotationDirection,i.texturePhase+=.08*h,i.alpha-=s<.08?.02+.04*(.08-s):.004,(i.alpha<=.05||i.radius>1*Math.max(this.width,this.height))&&this.rings.splice(t,1)}for(let t=this.pulses.length-1;t>=0;t--){const s=this.pulses[t];s.age+=1,s.radius+=s.speed,s.alpha*=.95,(s.age>s.life||s.alpha<.05)&&this.pulses.splice(t,1)}this.lastRms=s}onRender(){this.ctx.fillStyle=this.config.backgroundColor||"#000",this.ctx.fillRect(0,0,this.width,this.height);for(let t=this.rings.length-1;t>=0;t--){const s=this.rings[t];this._drawRing(s)}this._drawPulses()}_spawnRing({rms:t,centroid:s,flux:i,bass:e,mids:a,highs:h,growthSpeed:n,onset:r}){if(this.rings.length>=this.maxRings)return!1;const o=(this._centroidToHue(s)+this.hueDrift)%360,l=this.constrain(this.map(e,0,1,this.minThickness,this.maxThickness),this.minThickness,this.maxThickness),c=Math.round(this.map(a,0,1,this.minArms,this.maxArms)),d=Math.random()>.5?1:-1,p={createdAt:performance.now(),radius:this.baseRadius*(1+.6*this.rings.length),growthMultiplier:this.map(t,0,1,0,1.8),baseThickness:l,thickness:l,hue:o,alpha:r?1:.85,arms:c,textureSeed:1e3*Math.random(),texturePhase:0,rotation:Math.random()*Math.PI*2,rotationDirection:d,radialJitter:this.map(a,0,1,.02,.28)};return r&&(i>.25||t>.6)&&(p.arms=Math.min(this.maxArms,p.arms+Math.round(4*Math.random())),p.alpha=1),this.rings.push(p),!0}_canSpawn(){const t=performance.now();for(;this.spawnTimestamps.length&&t-this.spawnTimestamps[0]>1e3;)this.spawnTimestamps.shift();return!(this.spawnTimestamps.length>=this.maxSpawnsPerSecond)}_registerSpawn(){const t=performance.now();this.spawnTimestamps.push(t),this.lastSpawnTime=t,this.spawnTimestamps.length>2*this.maxSpawnsPerSecond&&this.spawnTimestamps.shift()}_spawnPulse({strength:t=.5,hue:s=200}={}){const i={x:this.centerX,y:this.centerY,radius:.8*this.baseRadius,speed:8+28*t,life:40+60*t,age:0,alpha:.9,hue:s};this.pulses.push(i)}_drawRing(t){const s=this.ctx;s.save(),s.translate(this.centerX,this.centerY),s.rotate(this.globalRotation+t.rotation);let i=t.hue%360;if(this.bassColorWave.active){const s=(performance.now()-this.bassColorWave.startTime)/this.bassColorWave.duration;if(s>=1)this.bassColorWave.active=!1;else{const e=1.4*Math.max(this.width,this.height),a=t.radius/e,h=.2,n=Math.abs(a-s);if(n<h){const t=1-n/h,s=Math.sin(t*Math.PI);i=this.lerp(i,this.bassColorWave.baseHue,.8*s)}}}const e=`hsl(${i}, 85%, ${this.map(t.thickness,this.minThickness,this.maxThickness,45,70)}%)`;s.strokeStyle=e,s.globalAlpha=this.constrain(t.alpha,0,1);const a=Math.max(1,t.arms),h=Math.min(1,Math.max(.25,Math.log2(1+t.radius/(this.baseRadius||1)))),n=Math.max(16,Math.floor(80*(1-.5*h)/1)),r=this.currentShape||"spiral";for(let e=0;e<a;e++){s.beginPath();const h=e/a*Math.PI*2;for(let i=0;i<n;i++){const e=i/Math.max(1,n-1);let a=t.radius*e;"spiral"===r?a=a+Math.sin(e*Math.PI*2*(1+.5*t.texturePhase))*t.radialJitter*t.radius+Math.sin(15*e+t.textureSeed+t.texturePhase)*t.radialJitter*t.radius*.5:"ring"===r&&(a=t.radius*(.95+.05*Math.sin(e*Math.PI*8+t.textureSeed)));const o=h+e*Math.PI*2*(.4+.5*t.growthMultiplier)+t.rotationDirection*this.globalRotation*.015,l=Math.cos(o)*a,c=Math.sin(o)*a;0===i?s.moveTo(l,c):s.lineTo(l,c)}s.lineWidth=Math.max(1,t.baseThickness*(1-Math.log10(1+t.radius)/6)),s.lineJoin="round",s.lineCap="round",s.shadowBlur=.3*t.baseThickness*Math.max(.5,s.globalAlpha),s.shadowColor=`hsl(${i}, 85%, 55%)`,s.stroke()}s.restore()}_drawPulses(){const t=this.ctx;for(let s=this.pulses.length-1;s>=0;s--){const i=this.pulses[s];t.save(),t.globalAlpha=Math.max(0,i.alpha*(1-i.age/i.life)),t.beginPath(),t.lineWidth=2+6*(1-t.globalAlpha),t.strokeStyle=`hsl(${Math.round(i.hue)}, 95%, 70%)`,t.shadowBlur=12*t.globalAlpha,t.shadowColor=`hsl(${Math.round(i.hue)}, 95%, 70%)`,t.arc(i.x,i.y,i.radius,0,2*Math.PI),t.stroke(),t.restore()}}_centroidToHue(t){const s=this.constrain(t,0,22050);return Math.round(this.map(s,0,22050,240,20))}}"undefined"!=typeof window&&(window.HypnoSpiralVisualizer=HypnoSpiralVisualizer);