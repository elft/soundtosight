class WebGLImageExplosionBETA extends BaseVisualizer{constructor(e,t={}){super(e,{...t}),this.fileInput=null,this.image=null,this.imageLoaded=!1,this._setupImageUpload()}async init(){this.audio={},this.exploding=!1,this.explodeAmount=0,this.lastEnergy=0,this.gridStep=4,this.maxPoints=65536,this.pointBase=1.75,this.pointEnergyScale=6,this.program=null,this.vao=null,this.buffers={},this.vertexCount=0,this.u={},this._buildProgram();const e=this.gl;e.clearColor(0,0,0,1),e.disable(e.DEPTH_TEST),e.enable(e.BLEND),e.blendFunc(e.SRC_ALPHA,e.ONE),this.start()}_setupImageUpload(){this.fileInput&&this.fileInput.parentNode&&this.fileInput.parentNode.removeChild(this.fileInput),this.fileInput=document.createElement("input"),this.fileInput.type="file",this.fileInput.accept="image/*",this.fileInput.style.display="none",document.body.appendChild(this.fileInput),this.fileInput.addEventListener("change",e=>{const t=e.target.files?.[0];t&&this.loadImage(t).catch(e=>{})}),this.canvas.style.cursor="pointer",this.canvas.addEventListener("click",()=>{this.fileInput.click()})}openImageSelector(){this.fileInput?.click()}async loadImage(e){const t=new Image,i=URL.createObjectURL(e);return new Promise((e,o)=>{t.onload=()=>{this.originalImage=t,this.imageAspectRatio=t.width/t.height,this.calculateImageDimensions(),this._buildPointCloudFromImage(),URL.revokeObjectURL(i),e()},t.onerror=()=>{URL.revokeObjectURL(i),o(new Error("Failed to load image"))},t.src=i})}calculateImageDimensions(){const e=this.width/this.height;this.imageAspectRatio>e?(this.drawWidth=this.width,this.drawHeight=this.width/this.imageAspectRatio):(this.drawHeight=this.height,this.drawWidth=this.height*this.imageAspectRatio),this.drawX=(this.width-this.drawWidth)/2,this.drawY=(this.height-this.drawHeight)/2}_buildPointCloudFromImage(){if(!this.image)return;const e=this.width,t=this.height,i=document.createElement("canvas");i.width=e,i.height=t;const o=i.getContext("2d"),{drawW:s,drawH:n,drawX:r,drawY:a}=this._fitImageToCanvas(this.image.width,this.image.height,e,t);o.clearRect(0,0,e,t),o.drawImage(this.image,r,a,s,n);const h=o.getImageData(0,0,e,t).data,l=[],u=[],d=[],p=Math.max(2,this.gridStep),f=.5*e,m=.5*t;for(let i=0;i<t;i+=p){for(let o=0;o<e;o+=p){if(o<r||o>r+s||i<a||i>a+n)continue;const p=4*(i*e+o);if(h[p+3]<110)continue;const c=h[p]/255,g=h[p+1]/255,b=h[p+2]/255,_=o/e*2-1,A=1-i/t*2;l.push(_,A,0),u.push(c,g,b);const v=(o-f)/e,x=(i-m)/t,y=Math.max(.05,Math.hypot(v,x)),w=v/y,R=x/y,I=.6;if(d.push(.6*w+(Math.random()-.5)*I,.6*R+(Math.random()-.5)*I,.7*(Math.random()-.5)),l.length/3>=this.maxPoints)break}if(l.length/3>=this.maxPoints)break}this.vertexCount=l.length/3;const c=this.gl;this.vao&&c.deleteVertexArray(this.vao),this.vao=c.createVertexArray(),c.bindVertexArray(this.vao),this.buffers.pos=this.buffers.pos||c.createBuffer(),c.bindBuffer(c.ARRAY_BUFFER,this.buffers.pos),c.bufferData(c.ARRAY_BUFFER,new Float32Array(l),c.STATIC_DRAW);const g=c.getAttribLocation(this.program,"a_position");c.enableVertexAttribArray(g),c.vertexAttribPointer(g,3,c.FLOAT,!1,0,0),this.buffers.col=this.buffers.col||c.createBuffer(),c.bindBuffer(c.ARRAY_BUFFER,this.buffers.col),c.bufferData(c.ARRAY_BUFFER,new Float32Array(u),c.STATIC_DRAW);const b=c.getAttribLocation(this.program,"a_color");c.enableVertexAttribArray(b),c.vertexAttribPointer(b,3,c.FLOAT,!1,0,0),this.buffers.seed=this.buffers.seed||c.createBuffer(),c.bindBuffer(c.ARRAY_BUFFER,this.buffers.seed),c.bufferData(c.ARRAY_BUFFER,new Float32Array(d),c.STATIC_DRAW);const _=c.getAttribLocation(this.program,"a_seed");c.enableVertexAttribArray(_),c.vertexAttribPointer(_,3,c.FLOAT,!1,0,0),c.bindVertexArray(null)}onUpdate(e){this.audio=e||{};const t=e?.rms??0,i=t-this.lastEnergy;this.lastEnergy=t,(e?.isMassiveEnergyChange||i>.25)&&(this.exploding=!this.exploding);const o=e?.aWeighted?.mono?.normalized??t;this.frozen=o<.05;const s=this.exploding?1:0,n=this.frozen?.02:.12;this.explodeAmount+=(s-this.explodeAmount)*n}onRender(){const e=this.gl;if(!e||!this.imageLoaded||!this.vertexCount)return;e.viewport(0,0,this.width,this.height),e.clear(e.COLOR_BUFFER_BIT),e.useProgram(this.program),e.bindVertexArray(this.vao);const t=this.audio||{};e.uniform1f(this.u.time,.001*performance.now()),e.uniform2f(this.u.res,this.width,this.height),e.uniform1f(this.u.energy,t.rms??0),e.uniform1f(this.u.bass,t.bassEnergy??0),e.uniform1f(this.u.treble,t.trebleEnergy??0),this._tempoTimer=(this._tempoTimer||0)+(.5+(t.tempo??120)/600)*(1/60);const i=.5*Math.sin(this._tempoTimer)+.5;e.uniform1f(this.u.explode,this.explodeAmount),e.uniform1f(this.u.pulse,i),e.uniform1f(this.u.pointBase,this.pointBase),e.uniform1f(this.u.pointEnergy,this.pointEnergyScale),e.drawArrays(e.POINTS,0,this.vertexCount),e.bindVertexArray(null),e.useProgram(null)}onResize(){this.imageLoaded&&this._buildPointCloudFromImage()}destroy(){const e=this.gl;if(this.fileInput&&this.fileInput.parentNode&&this.fileInput.parentNode.removeChild(this.fileInput),e){this.vao&&e.deleteVertexArray(this.vao);for(const t in this.buffers)this.buffers[t]&&e.deleteBuffer(this.buffers[t]);this.program&&e.deleteProgram(this.program)}super.destroy()}_buildProgram(){const e=this.gl,t=this._compileShader(e.VERTEX_SHADER,'#version 300 es\n        precision highp float;\n\n        in vec3 a_position;   // image position in clip space\n        in vec3 a_color;      // 0..1\n        in vec3 a_seed;       // random / direction\n\n        uniform float u_time;\n        uniform vec2  u_res;\n        uniform float u_energy;\n        uniform float u_bass;\n        uniform float u_treble;\n        uniform float u_explode;     // 0..1\n        uniform float u_pulse;       // 0..1 tempo pulse\n        uniform float u_pointBase;\n        uniform float u_pointEnergy;\n\n        out vec3 v_color;\n\n        void main() {\n            // Base position (assembled image)\n            vec3 pos = a_position;\n\n            // Explosion vector:\n            // seed gives outward direction; add bass “kick” & a tiny wobble from treble\n            float explodeStrength = (10.0 + u_bass * 60.0);\n            vec3 push = normalize(a_seed + vec3(1e-4)) * explodeStrength;\n\n            // Ease explode amount (sharper) and add tempo pulse to reassembly “spring”\n            float e = smoothstep(0.0, 1.0, u_explode);\n            float spring = (1.0 - e) * (0.85 + u_pulse * 0.25);\n\n            // Final position blends: assembled (pos) vs exploded (pos + push)\n            pos = mix(pos, pos + push, e);\n\n            // Subtle wobble in exploded state using time & seed\n            float wob = (sin(u_time * 1.7 + a_seed.x * 5.0) + cos(u_time * 2.3 + a_seed.y * 6.0)) * 0.015;\n            pos.xy += a_seed.xy * wob * e;\n\n            // Reassembly "spring" pulls back toward original as e->0 (already in mix),\n            // here we just add a tiny settle effect\n            pos.xy *= spring;\n\n            gl_Position = vec4(pos, 1.0);\n\n            // Point size in pixels: base + energy responsiveness\n            float p = u_pointBase + u_energy * u_pointEnergy;\n            // Scale a bit larger while exploding to feel like flying forward\n            p *= mix(1.0, 1.6, e);\n            gl_PointSize = p;\n\n            v_color = a_color;\n        }'),i=this._compileShader(e.FRAGMENT_SHADER,"#version 300 es\n        precision highp float;\n        in vec3 v_color;\n        out vec4 outColor;\n\n        void main() {\n            // Round point sprite\n            vec2 uv = gl_PointCoord - vec2(0.5);\n            float d = length(uv);\n            if (d > 0.5) discard;\n\n            // Soft falloff to avoid hard edges\n            float alpha = smoothstep(0.5, 0.0, d);\n\n            // Slight bloom look by lifting color a touch\n            vec3 col = v_color * 1.05;\n            outColor = vec4(col, alpha);\n        }"),o=e.createProgram();if(e.attachShader(o,t),e.attachShader(o,i),e.linkProgram(o),!e.getProgramParameter(o,e.LINK_STATUS))return e.deleteShader(t),e.deleteShader(i),void e.deleteProgram(o);e.deleteShader(t),e.deleteShader(i),this.program=o,this.u.time=e.getUniformLocation(o,"u_time"),this.u.res=e.getUniformLocation(o,"u_res"),this.u.energy=e.getUniformLocation(o,"u_energy"),this.u.bass=e.getUniformLocation(o,"u_bass"),this.u.treble=e.getUniformLocation(o,"u_treble"),this.u.explode=e.getUniformLocation(o,"u_explode"),this.u.pulse=e.getUniformLocation(o,"u_pulse"),this.u.pointBase=e.getUniformLocation(o,"u_pointBase"),this.u.pointEnergy=e.getUniformLocation(o,"u_pointEnergy")}_compileShader(e,t){const i=this.gl,o=i.createShader(e);return i.shaderSource(o,t),i.compileShader(o),i.getShaderParameter(o,i.COMPILE_STATUS)?o:(i.deleteShader(o),null)}}"undefined"!=typeof window&&(window.WebGLImageExplosionVisualizer=WebGLImageExplosionVisualizer);