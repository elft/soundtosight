class AudioManager{constructor(t=null,e={}){this.config={stereoMode:!0,...e},this.audioContext=null,this.sourceNode=null,this.splitter=null,this.merger=null,this.analyserLeft=null,this.analyserRight=null,this.leftData=null,this.rightData=null,this.monoData=null,this.previousFrequencyData=null,this.onAudioDataCallback=t,this.audioElement=null,this.mediaStream=null,this.mediaStreamSource=null,this.objectUrl=null,this.isMicActive=!1,this.analysisRunning=!1,this.isContextInitialized=!1,this.isPlaying=!1,this.featureHistory=new Map,this.fluxHistory=[],this.fluxTimes=[],this.beatTimestamps=[],this.bassHistory=[],this.tempoHistory=[],this.smoothedTempo=null,this._loop=this._loop.bind(this)}setStereoMode(t){this.config.stereoMode=t}async init(t=512){if(!this.isContextInitialized){if(this.audioContext=new(window.AudioContext||window.webkitAudioContext),this.highPassFilter=this.audioContext.createBiquadFilter(),this.highPassFilter.type="highpass",this.highPassFilter.frequency.value=20,this.highPassFilter.Q.value=.707,this.config.stereoMode){this.splitter=this.audioContext.createChannelSplitter(2),this.merger=this.audioContext.createChannelMerger(2),this.analyserLeft=this.audioContext.createAnalyser(),this.analyserRight=this.audioContext.createAnalyser(),this.analyserLeft.fftSize=t,this.analyserRight.fftSize=t;const e=this.analyserLeft.frequencyBinCount;this.leftData=new Uint8Array(e),this.rightData=new Uint8Array(e),this.monoData=new Uint8Array(e),this.leftTimeDomain=new Uint8Array(t),this.rightTimeDomain=new Uint8Array(t)}else{this.analyserLeft=this.audioContext.createAnalyser(),this.analyserLeft.fftSize=t;const e=this.analyserLeft.frequencyBinCount;this.monoData=new Uint8Array(e),this.leftData=this.monoData,this.rightData=this.monoData,this.leftTimeDomain=new Uint8Array(t),this.rightTimeDomain=this.leftTimeDomain}this._binCount=this.analyserLeft.frequencyBinCount,this._nyquist=this.audioContext.sampleRate/2,this._binFreqs=new Float32Array(this._binCount);for(let t=0;t<this._binCount;t++)this._binFreqs[t]=t/this._binCount*this._nyquist;this._bandEdges=[20,60,250,500,1e3,2e3,4e3,8e3,16e3,this._nyquist+1],this._bandRanges=[];{let t=Math.max(0,Math.floor(20/this._nyquist*this._binCount));for(let e=0;e<this._bandEdges.length;e++){const i=this._bandEdges[e],s=Math.min(this._binCount-1,Math.floor(i/this._nyquist*this._binCount));this._bandRanges.push([t,s]),t=s+1}}this._specF=new Float32Array(this._binCount),this._prevSpecF=new Float32Array(this._binCount),this._smoothSpec=new Float32Array(this._binCount),this._peakSpec=new Float32Array(this._binCount),this._lastT=this.audioContext.currentTime,this._dt=1/60,this._specHistoryLen=12,this._specHistory=Array.from({length:this._specHistoryLen},()=>new Float32Array(this._binCount)),this._specHistWrite=0,this.previousFrequencyData=new Uint8Array(this.leftData.length),this.isContextInitialized=!0,this._aWeightCurve=this.computeAWeightingCurve(this.audioContext.sampleRate,t)}}arSmooth(t,e,i=.04,s=.2){const a=this.featureHistory.get(t)??e,n=1-Math.exp(-this._dt/i),r=1-Math.exp(-this._dt/s),o=a+(e-a)*(e>a?n:r);return this.featureHistory.set(t,o),o}connectSource(t,e={}){if(!this.isContextInitialized)throw new Error("AudioManager not initialized");const{monitorPlayback:i=!0}=e;if(this.sourceNode=t,this.sourceNode.connect(this.highPassFilter),this.config.stereoMode?(this.highPassFilter.connect(this.splitter),this.splitter.connect(this.analyserLeft,0),this.splitter.connect(this.analyserRight,1)):this.highPassFilter.connect(this.analyserLeft),i)try{this.sourceNode.connect(this.audioContext.destination)}catch(t){}}async play(){if(this.isContextInitialized||await this.init(),this.audioContext&&"suspended"===this.audioContext.state)try{await this.audioContext.resume()}catch(t){}if(this.audioElement)try{await this.audioElement.play(),this.startAnalysis()}catch(t){throw this.isPlaying=!1,this._emitPlayStateChange(),t}}pause(){this.audioElement&&this.isPlaying&&(this.audioElement.pause(),this.isPlaying=!1,this._emitPlayStateChange())}stop(t={}){const{unload:e=!1}=t;if(this.audioElement){try{this.audioElement.pause()}catch(t){}try{this.audioElement.currentTime=0}catch(t){}}e&&this._releaseLoadedAudio(),this.isPlaying=!1,this.isMicActive=!1,this._emitPlayStateChange()}_releaseLoadedAudio(){if(this.audioElement){const t=this.audioElement;try{t.pause()}catch(t){}try{t.removeAttribute("src")}catch(t){}try{t.load?.()}catch(t){}try{t.remove()}catch(t){}this.audioElement=null}if(this.sourceNode){try{this.sourceNode.disconnect()}catch(t){}this.sourceNode=null}if(this.objectUrl){try{URL.revokeObjectURL(this.objectUrl)}catch(t){}this.objectUrl=null}}setAudioDataCallback(t){"function"==typeof t&&(this.audioDataCallback=t)}setPlayStateChangeCallback(t){"function"==typeof t&&(this.playStateChangeCallback=t)}_emitAudioData(t){this.audioDataCallback&&this.audioDataCallback(t)}_emitPlayStateChange(){this.playStateChangeCallback&&this.playStateChangeCallback(this.isPlaying,this.isMicActive)}_loop(){if(!this.isPlaying&&!this.isMicActive&&!this.audioElement)return void(this.analysisRunning=!1);const t=this.getAudioData();this._emitAudioData(t),requestAnimationFrame(this._loop)}getAudioData(){if(!this.isContextInitialized||!this.analyserLeft)return this._getEmptyAudioData();if(this.config.stereoMode){this.analyserLeft.getByteFrequencyData(this.leftData),this.analyserRight.getByteFrequencyData(this.rightData),this.analyserLeft.getByteTimeDomainData(this.leftTimeDomain),this.analyserRight.getByteTimeDomainData(this.rightTimeDomain);const t=this.leftData.length,e=new Uint8Array(t);for(let i=0;i<t;i++)e[i]=this.leftData[i]+this.rightData[i]>>1;this.monoData.set(e)}else this.analyserLeft.getByteFrequencyData(this.monoData),this.analyserLeft.getByteTimeDomainData(this.leftTimeDomain);const t=this.audioContext.currentTime;this._dt=Math.max(1/240,Math.min(.1,t-this._lastT)),this._lastT=t;const e=this.computeAudioFeatures(this.monoData,this.previousFrequencyData);let i,s,a;this.previousFrequencyData.set(this.monoData),this.config.stereoMode?(i=this.computeRMS(this.leftData),s=this.computeRMS(this.rightData),a=(s-i)/(i+s+1e-6)):(i=e.rms,s=e.rms);const n=this.estimateTempo(),r=this.predictNextBeat(n),o=e.rms,h=e.subBassEnergy,l=e.bassEnergy,c=e.lowMidEnergy,u=e.midEnergy,m=e.upperMidEnergy,d=e.presenceEnergy,p=e.trebleEnergy,g=e.brillianceEnergy,y=e.ultrasonicEnergy,f=e.centroid,b=e.flatness,C=e.bandCountActive,S=e.spectralFlux,M=a,x=(h+l+c+u+m+d+p+g+y)/9,D=(h+l+c+u+m+d+p+g+y)/9,E=D-(this.featureHistory.get("overallEnergy")||0),_=Math.abs(E);let T,F,A;this.config.stereoMode?(T=this.applyAWeightingToSpectrum(this.leftData,this._aWeightCurve),F=this.applyAWeightingToSpectrum(this.rightData,this._aWeightCurve),A=this.applyAWeightingToSpectrum(this.monoData,this._aWeightCurve)):(A=this.applyAWeightingToSpectrum(this.monoData,this._aWeightCurve),T=A,F=A),this.updateSmoothAndPeak(this.monoData),this.updateSpecHistory(this.monoData);const v=Math.max(0,Math.floor(20/(this.audioContext.sampleRate/2)*this.monoData.length)),w=this.computeSpectralFlatnessTrue(this.monoData,v),H=this.computeSpectralRolloff(this.monoData,.85,v),R=this.computeSpectralRolloff(this.monoData,.95,v),q=this.computeSpectralMoments(this.monoData,v),L=this.computeSpectralEntropy(this.monoData,v),P=this.interpDominantFreq(this.monoData,v),B=this.computeFluxByBand(this.monoData,this.previousFrequencyData??this.monoData,this._bandRanges),k=this.computeTimeRMS(this.leftTimeDomain),U=this.computeCrest(this.leftTimeDomain),z=this.computeZeroCrossingRate(this.leftTimeDomain);let N=0,W=0;if(this.config.stereoMode){const t=this.computeStereoStats(this.leftTimeDomain,this.rightTimeDomain);N=t.msRatio,W=t.icc}const{percussiveEnergy:I,harmonicEnergy:j}=this.computeHPSS(),O=this.arSmooth("loudShort",A.db??0,.1,.5),Z=this.arSmooth("loudInt",A.db??0,1.5,3),Q=this.computeTempoConfidence();this.featureHistory.set("overallEnergy",D);const G=B[5]+B[4],J=B[6]+B[7],K=G>(this.featureHistory.get("snareFluxAvg")??0)+2*(this.featureHistory.get("snareFluxStd")??.02),V=J>(this.featureHistory.get("hatFluxAvg")??0)+2*(this.featureHistory.get("hatFluxStd")??.02),X=(t,e,i=.08)=>this.featureHistory.set(t,(this.featureHistory.get(t)??e)+i*(e-(this.featureHistory.get(t)??e)));return X("snareFluxAvg",G),X("hatFluxAvg",J),X("snareFluxStd",Math.abs(G-(this.featureHistory.get("snareFluxAvg")??G))),X("hatFluxStd",Math.abs(J-(this.featureHistory.get("hatFluxAvg")??J))),{rms:o,energy:x,centroid:f,flatness:b,spectralFlux:S,subBassEnergy:h,bassEnergy:l,lowMidEnergy:c,midEnergy:u,upperMidEnergy:m,presenceEnergy:d,trebleEnergy:p,brillianceEnergy:g,ultrasonicEnergy:y,bandCountActive:Math.round(C),overallEnergy:D,energyChange:E,energyChangeIntensity:_,dominantBand:Math.max(h,l,c,u,m,d,p,g,y),isBeatSpike:e.isBeat&&_>.05,stereoSpread:Math.abs(a),bassDropIntensity:e.bassDrop?_:0,spectralCentroidNormalized:f/(this.audioContext.sampleRate/2),spectralFlatnessSmoothed:b,activeBandRatio:C/this.monoData.length,rmsDifference:s-i,isMassiveEnergyChange:_>.1,isBeat:e.isBeat,bassDrop:e.bassDrop,tempo:Math.round(n||0),time:this.audioContext.currentTime,predictedNextBeat:r,beatPhase:this.computeBeatPhase(n,r),stereoBalance:M,rmsLeft:i,rmsRight:s,aWeighted:{left:T,right:F,mono:A},dominantFreq:e.dominantFreq,frequencyLeft:this.leftData,frequencyRight:this.rightData,timeDomainLeft:this.leftTimeDomain,timeDomainRight:this.rightTimeDomain,rmsTime:k,crestTime:U,zcr:z,spectralFlatnessTrue:w,spectralRolloff85:H,spectralRolloff95:R,spectralSpreadHz:q.spread,spectralSkewness:q.skew,spectralSlope:q.slope,spectralEntropy:L,dominantFreqPrecise:P.freq,fluxByBand:B,midSideRatio:N,interchannelCorrelation:W,loudnessShortDb:O,loudnessIntegratedDb:Z,percussiveEnergy:I,harmonicEnergy:j,percussiveRatio:I/(I+j+1e-6),smoothedSpectrum:this._smoothSpec,peakSpectrum:this._peakSpec,tempoConfidence:Q,snareHit:K,hatTick:V}}_getEmptyAudioData(){return{rms:0,energy:0,centroid:0,flatness:0,spectralFlux:0,subBassEnergy:0,bassEnergy:0,lowMidEnergy:0,midEnergy:0,upperMidEnergy:0,presenceEnergy:0,trebleEnergy:0,brillianceEnergy:0,ultrasonicEnergy:0,bandCountActive:0,overallEnergy:0,energyChange:0,energyChangeIntensity:0,dominantBand:0,isBeatSpike:!1,stereoSpread:0,bassDropIntensity:0,spectralCentroidNormalized:0,spectralFlatnessSmoothed:0,activeBandRatio:0,rmsDifference:0,isMassiveEnergyChange:!1,isBeat:!1,bassDrop:!1,tempo:0,predictedNextBeat:null,beatPhase:0,stereoBalance:0,rmsLeft:0,rmsRight:0,dominantFreq:0,time:0,aWeighted:{left:{rms:0,db:0,normalized:0},right:{rms:0,db:0,normalized:0},mono:{rms:0,db:0,normalized:0}},frequencyLeft:new Uint8Array(0),frequencyRight:new Uint8Array(0),timeDomainLeft:new Uint8Array(0),timeDomainRight:new Uint8Array(0),rmsTime:0,crestTime:0,zcr:0,spectralFlatnessTrue:0,spectralRolloff85:0,spectralRolloff95:0,spectralSpreadHz:0,spectralSkewness:0,spectralSlope:0,spectralEntropy:0,dominantFreqPrecise:0,fluxByBand:new Float32Array(10),midSideRatio:0,interchannelCorrelation:0,loudnessShortDb:0,loudnessIntegratedDb:0,percussiveEnergy:0,harmonicEnergy:0,percussiveRatio:0,smoothedSpectrum:new Float32Array(0),peakSpectrum:new Float32Array(0),tempoConfidence:0,snareHit:!1,hatTick:!1}}computeAudioFeatures(t,e){const i=t.length,s=this.audioContext.sampleRate/2,a=Math.max(0,Math.floor(20/s*i));let n=0,r=0,o=0,h=0,l=0,c=0,u=0,m=0,d=0,p=0,g=0,y=0;for(let e=a;e<i;e++){const a=t[e];p+=a,a>32&&g++;const f=e/i*s;y+=f*a,f<60?n+=a:f<250?r+=a:f<500?o+=a:f<1e3?h+=a:f<2e3?l+=a:f<4e3?c+=a:f<8e3?u+=a:f<16e3?m+=a:d+=a}const f=y/(p+1e-6),b=p>0?g/(i-a):0,C=this.computeSpectralFlux(t,e,a),S=this.audioContext.currentTime;this.fluxHistory.push(C),this.fluxTimes.push(S),this.fluxHistory.length>512&&(this.fluxHistory.shift(),this.fluxTimes.shift());const M=this.detectBeatFromFlux(C,S);M&&(this.beatTimestamps.push(S),this.beatTimestamps.length>64&&this.beatTimestamps.shift());const x=n/((i-a)/128*255),D=r/((i-a)/16*255),E=o/((i-a)/64*255),_=h/((i-a)/32*255),T=l/((i-a)/32*255),F=c/((i-a)/16*255),A=u/((i-a)/16*255),v=m/((i-a)/32*255),w=d/((i-a)/64*255),H=this.detectBassDrop(D);let R=a,q=-1;for(let e=a;e<i;e++)t[e]>q&&(q=t[e],R=e);const L=R/i*s;return{rms:this.computeRMS(t,a),centroid:f,flatness:b,spectralFlux:C,subBassEnergy:x,bassEnergy:D,lowMidEnergy:E,midEnergy:_,upperMidEnergy:T,presenceEnergy:F,trebleEnergy:A,brillianceEnergy:v,ultrasonicEnergy:w,bandCountActive:g,isBeat:M,bassDrop:H,dominantFreq:L}}computeRMS(t,e=0){let i=0;const s=t.length;for(let a=e;a<s;a++){const e=t[a]/255;i+=e*e}return Math.sqrt(i/(s-e))}computeSpectralFlux(t,e,i=0){if(!e)return 0;let s=0;const a=t.length;for(let n=i;n<a;n++){const i=(t[n]-e[n])/255;i>0&&(s+=i)}return s/(a-i)}smoothFeature(t,e,i=.25){const s=this.featureHistory.get(t)??e,a=s+(e-s)*i;return this.featureHistory.set(t,a),a}computeSpectralFlatnessTrue(t,e=0){let i=0,s=0,a=0;for(let n=e;n<t.length;n++){const e=t[n]/255+1e-12;i+=Math.log(e),s+=e,a++}return Math.exp(i/Math.max(a,1))/(s/Math.max(a,1)+1e-12)}computeSpectralRolloff(t,e=.85,i=0){let s=0;for(let e=i;e<t.length;e++)s+=t[e];let a=s*e,n=0;for(let e=i;e<t.length;e++)if(n+=t[e],n>=a)return this._binFreqs[e];return this._binFreqs[t.length-1]}computeSpectralMoments(t,e=0){if(t.length-e<=0)return{spread:0,skew:0,slope:0};let i=0,s=0;for(let a=e;a<t.length;a++){const e=t[a];i+=e,s+=this._binFreqs[a]*e}const a=i>0?s/i:0;let n=0,r=0;for(let i=e;i<t.length;i++){const e=this._binFreqs[i],s=t[i],o=e-a;n+=s*o*o,r+=s*o*o*o}const o=i>0?n/i:0,h=Math.sqrt(Math.max(o,0)),l=i>0&&o>1e-12?r/i/Math.pow(o,1.5):0;let c=0,u=0,m=0,d=0,p=0;for(let i=e;i<t.length;i++){const e=Math.max(t[i]/255,1e-6),s=Math.log10(Math.max(this._binFreqs[i],1)),a=Math.log10(e);c+=s,u+=a,m+=s*s,d+=s*a,p++}return{centroidHz:a,spread:h,skew:l,slope:(p*d-c*u)/(p*m-c*c||1e-6)}}computeSpectralEntropy(t,e=0){let i=0;for(let s=e;s<t.length;s++)i+=t[s];if(i<=0)return 0;let s=0,a=0;for(let n=e;n<t.length;n++){const e=t[n]/i;e>0&&(s-=e*Math.log2(e),a++)}return s/Math.log2(Math.max(a,2))}computeTimeRMS(t){let e=0;for(let i=0;i<t.length;i++){const s=(t[i]-128)/128;e+=s*s}return Math.sqrt(e/t.length)}computeZeroCrossingRate(t){let e=0,i=t[0]-128;for(let s=1;s<t.length;s++){const a=t[s]-128;(a>=0&&i<0||a<0&&i>=0)&&e++,i=a}return e/(t.length-1)}computeCrest(t){let e=0;for(let i=0;i<t.length;i++){const s=Math.abs((t[i]-128)/128);s>e&&(e=s)}const i=this.computeTimeRMS(t);return i>1e-6?e/i:0}interpDominantFreq(t,e=0){let i=e,s=-1;for(let a=e;a<t.length;a++)t[a]>s&&(s=t[a],i=a);const a=Math.min(Math.max(i,1),t.length-2),n=t[a-1],r=t[a],o=t[a+1],h=a+.5*(n-o)/(n-2*r+o||1e-6);return{bin:h,freq:h/this._binCount*this._nyquist,mag:r}}computeFluxByBand(t,e,i){const s=new Float32Array(i.length);for(let a=0;a<i.length;a++){const[n,r]=i[a];let o=0;for(let i=n;i<=r;i++){const s=(t[i]-e[i])/255;s>0&&(o+=s)}s[a]=o/Math.max(1,r-n+1)}return s}computeStereoStats(t,e){let i=0,s=0,a=0,n=0,r=0,o=0,h=0,l=0;const c=Math.min(t.length,e.length);for(let u=0;u<c;u++){const c=(t[u]-128)/128,m=(e[u]-128)/128,d=.5*(c+m),p=.5*(c-m);i+=d*d,s+=p*p,n+=c,r+=m,o+=c*c,h+=m*m,l+=c*m,a++}const u=Math.sqrt(i/c),m=Math.sqrt(s/c);return{msRatio:u>1e-6?m/u:0,icc:(a*l-n*r)/(Math.sqrt((a*o-n*n)*(a*h-r*r))||1e-6)}}updateSmoothAndPeak(t){const e=1-Math.exp(-this._dt/.03),i=1-Math.exp(-this._dt/.2),s=Math.exp(-this._dt/.3);for(let a=0;a<this._binCount;a++){const n=t[a]/255,r=this._smoothSpec[a],o=r+(n-r)*(n>r?e:i);this._smoothSpec[a]=o,this._peakSpec[a]=Math.max(o,this._peakSpec[a]*s)}}updateSpecHistory(t){for(let e=0;e<this._binCount;e++)this._specF[e]=t[e]/255;this._specHistory[this._specHistWrite].set(this._specF),this._specHistWrite=(this._specHistWrite+1)%this._specHistoryLen}computeHPSS(){let t=0,e=0;for(let i=0;i<this._binCount;i++){let s=0;for(let t=-Math.floor(2.5);t<=Math.floor(2.5);t++){const e=Math.min(this._binCount-1,Math.max(0,i+t));s=Math.max(s,this._specF[e])}let a=0;for(let t=0;t<this._specHistoryLen;t++){const e=this._specHistory[t];a=Math.max(a,e[i])}const n=s+a+1e-6,r=a/n;t+=s/n*this._specF[i],e+=r*this._specF[i]}return{percussiveEnergy:t/this._binCount,harmonicEnergy:e/this._binCount}}computeTempoConfidence(){if(this.beatTimestamps.length<4)return 0;const t=[];for(let e=1;e<this.beatTimestamps.length;e++)t.push(this.beatTimestamps[e]-this.beatTimestamps[e-1]);const e=t.reduce((t,e)=>t+e,0)/t.length,i=Math.sqrt(t.reduce((t,i)=>t+(i-e)*(i-e),0)/t.length)/(e+1e-6);return this.constrain?this.constrain(1/(1+6*i),0,1):Math.max(0,Math.min(1,1/(1+6*i)))}detectBeatFromFlux(t,e){if(e-(this.beatTimestamps.length?this.beatTimestamps[this.beatTimestamps.length-1]:-9999)<.15)return!1;const i=this.fluxHistory;if(i.length<8)return!1;const s=i.slice(-16),a=s.reduce((t,e)=>t+e,0)/s.length,n=s.reduce((t,e)=>t+(e-a)**2,0)/s.length,r=Math.sqrt(n);return t>a+1.5*Math.max(.01,r)}detectBassDrop(t){if(this.bassHistory.push(t),this.bassHistory.length>120&&this.bassHistory.shift(),this.bassHistory.length<12)return!1;const e=this.bassHistory.reduce((t,e)=>t+e,0)/this.bassHistory.length;return t>2.2*e&&e<.1}estimateTempo(){if(this.beatTimestamps.length>=3){const t=[];for(let e=1;e<this.beatTimestamps.length;e++)t.push(this.beatTimestamps[e]-this.beatTimestamps[e-1]);t.sort((t,e)=>t-e);const e=60/t[Math.floor(t.length/2)];this.tempoHistory.push(e),this.tempoHistory.length>8&&this.tempoHistory.shift();const i=this.tempoHistory.reduce((t,e)=>t+e,0)/this.tempoHistory.length;return this.smoothedTempo=i,this.smoothedTempo}if(this.fluxHistory.length>=64&&this.fluxTimes.length>=64){const t=this.fluxTimes;let e=0;for(let i=1;i<t.length;i++)e+=t[i]-t[i-1];const i=e/(t.length-1),s=this.fluxHistory.slice(-256),a=40,n=240,r=Math.floor(60/n/i),o=Math.ceil(60/a/i),h=new Float32Array(o-r+1);for(let t=r;t<=o;t++){let e=0;for(let i=0;i<s.length-t;i++)e+=(s[i]-0)*(s[i+t]-0);h[t-r]=e}let l=0,c=-1/0;for(let t=0;t<h.length;t++)h[t]>c&&(c=h[t],l=t);const u=(r+l)*i;if(u>0&&isFinite(u)){const t=60/u;this.tempoHistory.push(t),this.tempoHistory.length>8&&this.tempoHistory.shift();const e=this.tempoHistory.reduce((t,e)=>t+e,0)/this.tempoHistory.length;return this.smoothedTempo=e,this.smoothedTempo}}return this.smoothedTempo||120}predictNextBeat(t){const e=this.audioContext.currentTime;if(!t||t<=0)return null;if(this.beatTimestamps.length>=2){const t=[];for(let e=1;e<this.beatTimestamps.length;e++)t.push(this.beatTimestamps[e]-this.beatTimestamps[e-1]);t.sort((t,e)=>t-e);const i=t[Math.floor(t.length/2)];let s=this.beatTimestamps[this.beatTimestamps.length-1]+i;for(;s<=e;)s+=i;return s}if(this.fluxTimes.length){this.fluxTimes.length>=2&&(this.fluxTimes[this.fluxTimes.length-1],this.fluxTimes[0],this.fluxTimes.length);const i=60/t;return e+(i-(e-this.fluxTimes[this.fluxTimes.length-1])%i)}return e+60/t}computeBeatPhase(t,e){if(!t||!e)return 0;const i=60/t;let s=1-(e-this.audioContext.currentTime)/i;return s=Math.max(0,Math.min(1,s)),s}aWeighting_dB(t){const e=t*t,i=Math.pow(12194.217,2)*Math.pow(t,4)/((e+Math.pow(20.598997,2))*(e+Math.pow(12194.217,2))*Math.sqrt((e+Math.pow(107.65265,2))*(e+Math.pow(737.86223,2))));return 20*Math.log10(i)+2}computeAWeightingCurve(t,e){const i=e/2,s=t/2,a=new Float32Array(i);for(let t=0;t<i;t++){const e=t/i*s,n=Math.max(1e-6,e);a[t]=this.aWeighting_dB(n)}return a}applyAWeightingToSpectrum(t,e){const i=Math.min(t.length,e.length);let s=0,a=0;for(let n=0;n<i;n++){const i=t[n]/255*Math.pow(10,e[n]/20);s+=i*i,a+=i}const n=Math.sqrt(s/i);return{rms:n,db:n>0?20*Math.log10(n):-1/0,normalized:Math.min(1,a/i)}}startAnalysis(){this.analysisRunning||(this.analysisRunning=!0,requestAnimationFrame(this._loop))}stopAnalysis(){this.analysisRunning=!1}async loadFile(t){if(!t)throw new Error("No file provided");this.isContextInitialized||await this.init(),this._releaseLoadedAudio();const e=URL.createObjectURL(t);this.objectUrl=e;const i=document.createElement("audio");i.controls=!1,i.preload="auto",i.src=e,i.crossOrigin="anonymous";try{const t=this.audioContext.createMediaElementSource(i);this.connectSource(t)}catch(t){}return i.addEventListener("play",async()=>{if(this.audioContext&&"suspended"===this.audioContext.state)try{await this.audioContext.resume()}catch(t){}this.isPlaying=!0,this._emitPlayStateChange(),this.startAnalysis()}),i.addEventListener("pause",()=>{this.isPlaying=!1,this._emitPlayStateChange()}),i.addEventListener("ended",()=>{this.isPlaying=!1,this._emitPlayStateChange()}),this.audioElement=i,new Promise((t,e)=>{const s=()=>{n(),t()},a=t=>{n(),e(new Error("Audio failed to load"))},n=()=>{i.removeEventListener("canplay",s),i.removeEventListener("error",a)};i.addEventListener("canplay",s),i.addEventListener("error",a);try{i.load()}catch(t){}})}async loadStreamFromUrl(t){if(!t)throw new Error("No stream URL provided");this.isContextInitialized||await this.init(),this._releaseLoadedAudio();const e=document.createElement("audio");e.controls=!1,e.preload="auto",e.src=t,e.crossOrigin="anonymous";try{const t=this.audioContext.createMediaElementSource(e);this.connectSource(t)}catch(t){}return e.addEventListener("play",async()=>{if(this.audioContext&&"suspended"===this.audioContext.state)try{await this.audioContext.resume()}catch(t){}this.isPlaying=!0,this._emitPlayStateChange(),this.startAnalysis()}),e.addEventListener("pause",()=>{this.isPlaying=!1,this._emitPlayStateChange()}),e.addEventListener("ended",()=>{this.isPlaying=!1,this._emitPlayStateChange()}),this.audioElement=e,new Promise((t,i)=>{const s=()=>{n(),t()},a=()=>{n(),i(new Error("Stream failed to load"))},n=()=>{e.removeEventListener("canplay",s),e.removeEventListener("error",a)};e.addEventListener("canplay",s),e.addEventListener("error",a);try{e.load()}catch(t){}})}async startMicrophone(){if(!navigator.mediaDevices||!navigator.mediaDevices.getUserMedia)throw new Error("getUserMedia not available");this.isContextInitialized||await this.init(),"suspended"===this.audioContext.state&&await this.audioContext.resume();const t=await navigator.mediaDevices.getUserMedia({audio:!0});this.mediaStream=t;const e=this.audioContext.createMediaStreamSource(t);this.mediaStreamSource=e,this.connectSource(e,{monitorPlayback:!1}),this.isMicActive=!0,this._emitPlayStateChange(),this.startAnalysis()}stopMicrophone(){if(this.mediaStream&&(this.mediaStream.getTracks().forEach(t=>t.stop()),this.mediaStream=null),this.mediaStreamSource){try{this.mediaStreamSource.disconnect()}catch(t){}this.mediaStreamSource=null}this.isMicActive=!1,this._emitPlayStateChange()}onAudioData(t){this.setAudioDataCallback(t)}onPlayStateChange(t){this.setPlayStateChangeCallback(t)}destroy(){if(this.cleanup(),this.audioContext){try{this.audioContext.close()}catch(t){}this.audioContext=null}}cleanup(){if(this.analysisRunning=!1,this.audioElement){try{this.audioElement.pause()}catch(t){}try{this.audioElement.removeAttribute("src")}catch(t){}try{const t=this.audioElement.parentNode,e=this.audioElement.cloneNode(!1);t&&t.replaceChild(e,this.audioElement)}catch(t){}this.audioElement=null}if(this.objectUrl){try{URL.revokeObjectURL(this.objectUrl)}catch(t){}this.objectUrl=null}if(this.mediaStream){try{this.mediaStream.getTracks().forEach(t=>t.stop())}catch(t){}this.mediaStream=null}if(this.mediaStreamSource){try{this.mediaStreamSource.disconnect()}catch(t){}this.mediaStreamSource=null}if(this.sourceNode){try{this.sourceNode.disconnect()}catch(t){}this.sourceNode=null}if(this.highPassFilter){try{this.highPassFilter.disconnect()}catch(t){}this.highPassFilter=null}if(this.splitter){try{this.splitter.disconnect()}catch(t){}this.splitter=null}if(this.merger){try{this.merger.disconnect()}catch(t){}this.merger=null}if(this.analyserLeft){try{this.analyserLeft.disconnect()}catch(t){}this.analyserLeft=null}if(this.analyserRight){try{this.analyserRight.disconnect()}catch(t){}this.analyserRight=null}this.leftData=null,this.rightData=null,this.previousFrequencyData=null,this.isMicActive=!1,this.isPlaying=!1,this.isContextInitialized=!1,this.featureHistory.clear?.(),this.fluxHistory.length=0,this.fluxTimes.length=0,this.beatTimestamps.length=0,this.bassHistory.length=0,this.tempoHistory.length=0}}window.AudioManager=AudioManager;